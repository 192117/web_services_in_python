# Описание заданий

## 1. **_Практика по requests._**

В этом задании вы научитесь работать с библиотекой requests (https://requests.kennethreitz.org/en/master/), а также 
научитесь работать с API сервиса VK и его документаций, что является достаточно частой задачей разработчика.

Необходимо написать клиент к API VK , который будет считать распределение возрастов друзей для указанного пользователя. 
То есть на вход подается username или user_id пользователя, на выходе получаем **список пар (<возраст>, <количество 
друзей с таким возрастом>), отсортированный по убыванию по второму ключу (количество друзей) и по возрастанию по 
первому ключу (возраст)**. Например: 

```
[(26, 8), (21, 6), (22, 6), (40, 2), (19, 1), (20, 1)]
```

Для выполнения задания необходимо использовать шаблон проекта: https://github.com/alexopryshko/coursera_assignment_tmp

Решение должно быть файлом **req/friends.py**. В этом файле представлен шаблон функции **calc_age**, реализацию которой 
нужно написать.

Для этого вам понадобятся два метода **API VK**: 

1. Метод для получения id пользователя (https://vk.com/dev/users.get). Он необходим, так как на вход может подаваться 
username пользователя. URL запроса к API VK: https://api.vk.com/method/users.get

2. Метод для получения списка друзей пользователя (https://vk.com/dev/friends.get). URL запроса к API VK: 
https://api.vk.com/method/friends.get

Для доступа к этим методам вам понадобится “Сервисный ключ доступа”:

https://vk.com/dev/access_token?f=3.%20%D0%A1%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BD%D1%8B%D0%B9%20%D0%BA%D0%BB%D1%8E%D1%87%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0

Получение сервисного ключа:

1. Создать новое приложение, перейдя по ссылке https://vk.com/apps?act=manage

2. После создания приложения, перейти в раздел “настройки” и скопировать “Сервисный ключ доступа”.

**Если нет возможности получить сервисный ключ, то можно использовать уже созданный.**

В итоге запросы будут иметь вид: 

- Для получения id пользователя по username или user_id:

    https://api.vk.com/method/users.get?v=5.71&access_token=[token]&user_ids=[user_id]

- Для получения списка друзей:

    https://api.vk.com/method/friends.get?v=5.71&access_token=[token]&user_id=[user_id]&fields=bdate

При решении задания обратите внимание на несколько моментов. 

- В запросе мы  используем версию  API VK - «5.81».

- В запросе получения списка друзей добавлен ключ fields=bdate.  Он необходим для того, чтобы API сразу вернуло 
пользователей с датами рождения.

- При анализе ответа, полученного методом friends.get, можно заметить, что bdate есть не у всех пользователей и у 
- некоторых в bdate отсутствует год рождения. Поэтому необходимо пропускать этот случай. Примеры возможных значений: 
- "bdate":"6.6", "bdate":"25.8.1993". Для вычисления возраста, необходимо взять текущий год,  и вычесть из него год 
- рождения пользователя, полученный из API (без учета месяца и числа).

В своем решении вы можете (если необходимо) определять дополнительные функции и импортировать модули. 

2. **_Практическое задание по регулярным выражениям._**

В этом задании нужно написать программу, которая найдет в тексте ряд простых арифметических выражений и подсчитает их.

Любое выражение начинается с имени переменной **a**, **b** или **c**, затем может идти + или -, затем идет =, затем 
может идти имя переменной a, b или c, а затем может идти + или - и целое число. Если в правой части выражения нет 
переменной, то число может быть без знака + или -

Не бывает названий переменных, кроме a, b или c, и действий, кроме описанных тут. Не бывает пробелов вокруг знаков. В 
тексте не встречаются некорректные выражения, в которых справа от = нет ни переменной, ни числа. Таким образом, список 
типов выражений, которые могут встречаться, выглядит примерно так:

a=1, a=+1, a=-1, a=b, a=b+100, a=b-100, b+=10, b+=+10, b+=-10, b+=b, b+=b+100, b+=b-100, c-=101, c-=+101, c-=-101, 
c-=b, c-=b+101, c-=b-101

Выражения могут встречаться внутри текста, например loremc-=a+10ipsuma-=adb+=10olorsitamet.

В вашу функцию calculate(data, findall) будет передан словарь с начальными значениями переменных a, b и c: 
data = {"a":1, "b":2, "c": 3} и ссылка на функцию findall, а вы должны вернуть такой же словарь с новыми значениями 
для a, b и c.

Работает findall() аналогично re.findall(), только у нее всего один параметр – регулярное выражение. А текст, в котором
она будет искать выражения, она знает сама (см. приложенный архив, чтобы понять, о чем речь). С помощью findall() нужно 
как минимум найти все выражения в тексте, а как максимум найти их и разбить на группы так, чтобы было удобно их 
обработать. _Если findall() будет вызвано больше одного раза или если размер списка, который она вернет, будет 
отличаться от количества выражений в тексте, тест провалится_.

Эталонное решение занимает 11 строк, не содержит импортов, не использует eval, а регулярное выражение находит выражения 
и бьет каждое на четыре группы (некоторые группы для некоторых выражений оказываются пустыми):

- Имя переменной слева.
- Знак перед = (если есть).
- Имя переменной справа (если есть).
- Число (если есть) со знаком (если есть).

Это позволяет легко (буквально в одну строку) посчитать правую часть, а потом, в зависимости от наличия знака перед =, 
произвести действие с левой частью. Однако ваш алгоритм может быть другим, требуется только выполнить ограничения на 
вызов findall() и оставить сигнатуру calculate() неизменной. 

Вы должны скачать архив к этому уроку, изучить оба файла и переписать функцию calculate() внутри regexp.py. Для 
проверки вашего решения локально запустите python test.py. На сервере задание будет проверяться похожим образом, но 
реализация findall() будет иной (с проверкой всех ограничений), и тестов будет несколько. Решением будет файл 
regexp.py, который надо загрузить на сервер для проверки.

